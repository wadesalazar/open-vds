/****************************************************************************
** Copyright 2019 The Open Group
** Copyright 2019 Bluware, Inc.
**
** Licensed under the Apache License, Version 2.0 (the "License");
** you may not use this file except in compliance with the License.
** You may obtain a copy of the License at
**
**     http://www.apache.org/licenses/LICENSE-2.0
**
** Unless required by applicable law or agreed to in writing, software
** distributed under the License is distributed on an "AS IS" BASIS,
** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
** See the License for the specific language governing permissions and
** limitations under the License.
****************************************************************************/

#include "PyVolumeDataAccessManager.h"

using namespace native;

void 
PyVolumeDataAccessManager::initModule(py::module& m)
{
//AUTOGEN-BEGIN
  // IVolumeDataAccessManager
  py::class_<IVolumeDataAccessManager, std::unique_ptr<IVolumeDataAccessManager, py::nodelete>> 
    IVolumeDataAccessManager_(m,"IVolumeDataAccessManager", OPENVDS_DOCSTRING(IVolumeDataAccessManager));

  IVolumeDataAccessManager_.def("addRef"                      , static_cast<void(IVolumeDataAccessManager::*)()>(&IVolumeDataAccessManager::AddRef), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_AddRef));
  IVolumeDataAccessManager_.def("release"                     , static_cast<void(IVolumeDataAccessManager::*)()>(&IVolumeDataAccessManager::Release), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Release));
  IVolumeDataAccessManager_.def("refCount"                    , static_cast<int(IVolumeDataAccessManager::*)() const>(&IVolumeDataAccessManager::RefCount), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_RefCount));
  IVolumeDataAccessManager_.def("getVolumeDataLayout"         , static_cast<const native::VolumeDataLayout *(IVolumeDataAccessManager::*)()>(&IVolumeDataAccessManager::GetVolumeDataLayout), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetVolumeDataLayout));
  IVolumeDataAccessManager_.def_property_readonly("volumeDataLayout", &IVolumeDataAccessManager::GetVolumeDataLayout, OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetVolumeDataLayout));
  IVolumeDataAccessManager_.def("getVDSProduceStatus"         , static_cast<native::VDSProduceStatus(IVolumeDataAccessManager::*)(native::DimensionsND, int, int)>(&IVolumeDataAccessManager::GetVDSProduceStatus), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetVDSProduceStatus));
  IVolumeDataAccessManager_.def("createVolumeDataPageAccessor", static_cast<native::VolumeDataPageAccessor *(IVolumeDataAccessManager::*)(native::DimensionsND, int, int, int, VolumeDataPageAccessor::AccessMode, int)>(&IVolumeDataAccessManager::CreateVolumeDataPageAccessor), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("accessMode").none(false), py::arg("chunkMetadataPageSize") = 1024, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_CreateVolumeDataPageAccessor));
  IVolumeDataAccessManager_.def("destroyVolumeDataPageAccessor", static_cast<void(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *)>(&IVolumeDataAccessManager::DestroyVolumeDataPageAccessor), py::arg("volumeDataPageAccessor").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_DestroyVolumeDataPageAccessor));
  IVolumeDataAccessManager_.def("destroyVolumeDataAccessor"   , static_cast<void(IVolumeDataAccessManager::*)(native::IVolumeDataAccessor *)>(&IVolumeDataAccessManager::DestroyVolumeDataAccessor), py::arg("accessor").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_DestroyVolumeDataAccessor));
  IVolumeDataAccessManager_.def("cloneVolumeDataAccessor"     , static_cast<native::IVolumeDataAccessor *(IVolumeDataAccessManager::*)(const native::IVolumeDataAccessor &)>(&IVolumeDataAccessManager::CloneVolumeDataAccessor), py::arg("accessor").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_CloneVolumeDataAccessor));
  IVolumeDataAccessManager_.def("create2DVolumeDataAccessor1Bit", static_cast<IVolumeDataReadWriteAccessor<native::IntVector2, bool> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create2DVolumeDataAccessor1Bit), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DVolumeDataAccessor1Bit));
  IVolumeDataAccessManager_.def("create2DVolumeDataAccessorU8", static_cast<IVolumeDataReadWriteAccessor<native::IntVector2, uint8_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create2DVolumeDataAccessorU8), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DVolumeDataAccessorU8));
  IVolumeDataAccessManager_.def("create2DVolumeDataAccessorU16", static_cast<IVolumeDataReadWriteAccessor<native::IntVector2, uint16_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create2DVolumeDataAccessorU16), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DVolumeDataAccessorU16));
  IVolumeDataAccessManager_.def("create2DVolumeDataAccessorU32", static_cast<IVolumeDataReadWriteAccessor<native::IntVector2, uint32_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create2DVolumeDataAccessorU32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DVolumeDataAccessorU32));
  IVolumeDataAccessManager_.def("create2DVolumeDataAccessorU64", static_cast<IVolumeDataReadWriteAccessor<native::IntVector2, uint64_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create2DVolumeDataAccessorU64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DVolumeDataAccessorU64));
  IVolumeDataAccessManager_.def("create2DVolumeDataAccessorR32", static_cast<IVolumeDataReadWriteAccessor<native::IntVector2, float> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create2DVolumeDataAccessorR32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DVolumeDataAccessorR32));
  IVolumeDataAccessManager_.def("create2DVolumeDataAccessorR64", static_cast<IVolumeDataReadWriteAccessor<native::IntVector2, double> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create2DVolumeDataAccessorR64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DVolumeDataAccessorR64));
  IVolumeDataAccessManager_.def("create3DVolumeDataAccessor1Bit", static_cast<IVolumeDataReadWriteAccessor<native::IntVector3, bool> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create3DVolumeDataAccessor1Bit), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DVolumeDataAccessor1Bit));
  IVolumeDataAccessManager_.def("create3DVolumeDataAccessorU8", static_cast<IVolumeDataReadWriteAccessor<native::IntVector3, uint8_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create3DVolumeDataAccessorU8), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DVolumeDataAccessorU8));
  IVolumeDataAccessManager_.def("create3DVolumeDataAccessorU16", static_cast<IVolumeDataReadWriteAccessor<native::IntVector3, uint16_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create3DVolumeDataAccessorU16), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DVolumeDataAccessorU16));
  IVolumeDataAccessManager_.def("create3DVolumeDataAccessorU32", static_cast<IVolumeDataReadWriteAccessor<native::IntVector3, uint32_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create3DVolumeDataAccessorU32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DVolumeDataAccessorU32));
  IVolumeDataAccessManager_.def("create3DVolumeDataAccessorU64", static_cast<IVolumeDataReadWriteAccessor<native::IntVector3, uint64_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create3DVolumeDataAccessorU64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DVolumeDataAccessorU64));
  IVolumeDataAccessManager_.def("create3DVolumeDataAccessorR32", static_cast<IVolumeDataReadWriteAccessor<native::IntVector3, float> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create3DVolumeDataAccessorR32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DVolumeDataAccessorR32));
  IVolumeDataAccessManager_.def("create3DVolumeDataAccessorR64", static_cast<IVolumeDataReadWriteAccessor<native::IntVector3, double> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create3DVolumeDataAccessorR64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DVolumeDataAccessorR64));
  IVolumeDataAccessManager_.def("create4DVolumeDataAccessor1Bit", static_cast<IVolumeDataReadWriteAccessor<native::IntVector4, bool> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create4DVolumeDataAccessor1Bit), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DVolumeDataAccessor1Bit));
  IVolumeDataAccessManager_.def("create4DVolumeDataAccessorU8", static_cast<IVolumeDataReadWriteAccessor<native::IntVector4, uint8_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create4DVolumeDataAccessorU8), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DVolumeDataAccessorU8));
  IVolumeDataAccessManager_.def("create4DVolumeDataAccessorU16", static_cast<IVolumeDataReadWriteAccessor<native::IntVector4, uint16_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create4DVolumeDataAccessorU16), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DVolumeDataAccessorU16));
  IVolumeDataAccessManager_.def("create4DVolumeDataAccessorU32", static_cast<IVolumeDataReadWriteAccessor<native::IntVector4, uint32_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create4DVolumeDataAccessorU32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DVolumeDataAccessorU32));
  IVolumeDataAccessManager_.def("create4DVolumeDataAccessorU64", static_cast<IVolumeDataReadWriteAccessor<native::IntVector4, uint64_t> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create4DVolumeDataAccessorU64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DVolumeDataAccessorU64));
  IVolumeDataAccessManager_.def("create4DVolumeDataAccessorR32", static_cast<IVolumeDataReadWriteAccessor<native::IntVector4, float> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create4DVolumeDataAccessorR32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DVolumeDataAccessorR32));
  IVolumeDataAccessManager_.def("create4DVolumeDataAccessorR64", static_cast<IVolumeDataReadWriteAccessor<native::IntVector4, double> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float)>(&IVolumeDataAccessManager::Create4DVolumeDataAccessorR64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DVolumeDataAccessorR64));
  IVolumeDataAccessManager_.def("create2DInterpolatingVolumeDataAccessorR32", static_cast<IVolumeDataReadAccessor<native::FloatVector2, float> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float, native::InterpolationMethod)>(&IVolumeDataAccessManager::Create2DInterpolatingVolumeDataAccessorR32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::arg("interpolationMethod").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DInterpolatingVolumeDataAccessorR32));
  IVolumeDataAccessManager_.def("create2DInterpolatingVolumeDataAccessorR64", static_cast<IVolumeDataReadAccessor<native::FloatVector2, double> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float, native::InterpolationMethod)>(&IVolumeDataAccessManager::Create2DInterpolatingVolumeDataAccessorR64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::arg("interpolationMethod").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create2DInterpolatingVolumeDataAccessorR64));
  IVolumeDataAccessManager_.def("create3DInterpolatingVolumeDataAccessorR32", static_cast<IVolumeDataReadAccessor<native::FloatVector3, float> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float, native::InterpolationMethod)>(&IVolumeDataAccessManager::Create3DInterpolatingVolumeDataAccessorR32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::arg("interpolationMethod").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DInterpolatingVolumeDataAccessorR32));
  IVolumeDataAccessManager_.def("create3DInterpolatingVolumeDataAccessorR64", static_cast<IVolumeDataReadAccessor<native::FloatVector3, double> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float, native::InterpolationMethod)>(&IVolumeDataAccessManager::Create3DInterpolatingVolumeDataAccessorR64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::arg("interpolationMethod").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create3DInterpolatingVolumeDataAccessorR64));
  IVolumeDataAccessManager_.def("create4DInterpolatingVolumeDataAccessorR32", static_cast<IVolumeDataReadAccessor<native::FloatVector4, float> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float, native::InterpolationMethod)>(&IVolumeDataAccessManager::Create4DInterpolatingVolumeDataAccessorR32), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::arg("interpolationMethod").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DInterpolatingVolumeDataAccessorR32));
  IVolumeDataAccessManager_.def("create4DInterpolatingVolumeDataAccessorR64", static_cast<IVolumeDataReadAccessor<native::FloatVector4, double> *(IVolumeDataAccessManager::*)(native::VolumeDataPageAccessor *, float, native::InterpolationMethod)>(&IVolumeDataAccessManager::Create4DInterpolatingVolumeDataAccessorR64), py::arg("volumeDataPageAccessor").none(false), py::arg("replacementNoValue").none(false), py::arg("interpolationMethod").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Create4DInterpolatingVolumeDataAccessorR64));
  IVolumeDataAccessManager_.def("getVolumeSubsetBufferSize"   , [](IVolumeDataAccessManager* self, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, VolumeDataChannelDescriptor::Format format, int LOD, int channel) { return self->GetVolumeSubsetBufferSize(PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), format, LOD, channel); }, py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("format").none(false), py::arg("LOD") = 0, py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetVolumeSubsetBufferSize));
  IVolumeDataAccessManager_.def("requestVolumeSubset"         , [](IVolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, VolumeDataChannelDescriptor::Format format, optional<float> replacementNoValue) { return self->RequestVolumeSubset(PyGetBufferPtr<void, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), format, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("format").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_RequestVolumeSubset));
  IVolumeDataAccessManager_.def("getProjectedVolumeSubsetBufferSize", [](IVolumeDataAccessManager* self, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, OpenVDS::DimensionsND projectedDimensions, VolumeDataChannelDescriptor::Format format, int LOD, int channel) { return self->GetProjectedVolumeSubsetBufferSize(PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), projectedDimensions, format, LOD, channel); }, py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("projectedDimensions").none(false), py::arg("format").none(false), py::arg("LOD") = 0, py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetProjectedVolumeSubsetBufferSize));
  IVolumeDataAccessManager_.def("requestProjectedVolumeSubset", [](IVolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, FloatVector4Adapter::AdaptedType voxelPlane, OpenVDS::DimensionsND projectedDimensions, VolumeDataChannelDescriptor::Format format, OpenVDS::InterpolationMethod interpolationMethod, optional<float> replacementNoValue) { return self->RequestProjectedVolumeSubset(PyGetBufferPtr<void, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), voxelPlane, projectedDimensions, format, interpolationMethod, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("voxelPlane").none(false), py::arg("projectedDimensions").none(false), py::arg("format").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_RequestProjectedVolumeSubset));
  IVolumeDataAccessManager_.def("getVolumeSamplesBufferSize"  , static_cast<int64_t(IVolumeDataAccessManager::*)(int, int)>(&IVolumeDataAccessManager::GetVolumeSamplesBufferSize), py::arg("sampleCount").none(false), py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetVolumeSamplesBufferSize));
  IVolumeDataAccessManager_.def("requestVolumeSamples"        , [](IVolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<float,py::array::forcecast>& samplePositions, int sampleCount, OpenVDS::InterpolationMethod interpolationMethod, optional<float> replacementNoValue) { return self->RequestVolumeSamples(PyGetBufferPtr<float, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<float, 6, false>::getArrayPtrChecked(samplePositions), sampleCount, interpolationMethod, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("samplePositions").none(false), py::arg("sampleCount").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_RequestVolumeSamples));
  IVolumeDataAccessManager_.def("getVolumeTracesBufferSize"   , static_cast<int64_t(IVolumeDataAccessManager::*)(int, int, int, int)>(&IVolumeDataAccessManager::GetVolumeTracesBufferSize), py::arg("traceCount").none(false), py::arg("traceDimension").none(false), py::arg("LOD") = 0, py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetVolumeTracesBufferSize));
  IVolumeDataAccessManager_.def("requestVolumeTraces"         , [](IVolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<float,py::array::forcecast>& tracePositions, int traceCount, OpenVDS::InterpolationMethod interpolationMethod, int traceDimension, optional<float> replacementNoValue) { return self->RequestVolumeTraces(PyGetBufferPtr<float, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<float, 6, false>::getArrayPtrChecked(tracePositions), traceCount, interpolationMethod, traceDimension, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("tracePositions").none(false), py::arg("traceCount").none(false), py::arg("interpolationMethod").none(false), py::arg("traceDimension").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_RequestVolumeTraces));
  IVolumeDataAccessManager_.def("prefetchVolumeChunk"         , static_cast<int64_t(IVolumeDataAccessManager::*)(native::DimensionsND, int, int, int64_t)>(&IVolumeDataAccessManager::PrefetchVolumeChunk), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("chunkIndex").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_PrefetchVolumeChunk));
  IVolumeDataAccessManager_.def("isCompleted"                 , static_cast<bool(IVolumeDataAccessManager::*)(int64_t)>(&IVolumeDataAccessManager::IsCompleted), py::arg("requestID").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_IsCompleted));
  IVolumeDataAccessManager_.def("isCanceled"                  , static_cast<bool(IVolumeDataAccessManager::*)(int64_t)>(&IVolumeDataAccessManager::IsCanceled), py::arg("requestID").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_IsCanceled));
  IVolumeDataAccessManager_.def("waitForCompletion"           , static_cast<bool(IVolumeDataAccessManager::*)(int64_t, int)>(&IVolumeDataAccessManager::WaitForCompletion), py::arg("requestID").none(false), py::arg("millisecondsBeforeTimeout") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_WaitForCompletion));
  IVolumeDataAccessManager_.def("cancel"                      , static_cast<void(IVolumeDataAccessManager::*)(int64_t)>(&IVolumeDataAccessManager::Cancel), py::arg("requestID").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_Cancel));
  IVolumeDataAccessManager_.def("cancelAndWaitForCompletion"  , static_cast<void(IVolumeDataAccessManager::*)(int64_t)>(&IVolumeDataAccessManager::CancelAndWaitForCompletion), py::arg("requestID").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_CancelAndWaitForCompletion));
  IVolumeDataAccessManager_.def("getCompletionFactor"         , static_cast<float(IVolumeDataAccessManager::*)(int64_t)>(&IVolumeDataAccessManager::GetCompletionFactor), py::arg("requestID").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetCompletionFactor));
  IVolumeDataAccessManager_.def("flushUploadQueue"            , static_cast<void(IVolumeDataAccessManager::*)(bool)>(&IVolumeDataAccessManager::FlushUploadQueue), py::arg("writeUpdatedLayerStatus") = true, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_FlushUploadQueue));
  IVolumeDataAccessManager_.def("clearUploadErrors"           , static_cast<void(IVolumeDataAccessManager::*)()>(&IVolumeDataAccessManager::ClearUploadErrors), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_ClearUploadErrors));
  IVolumeDataAccessManager_.def("forceClearAllUploadErrors"   , static_cast<void(IVolumeDataAccessManager::*)()>(&IVolumeDataAccessManager::ForceClearAllUploadErrors), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_ForceClearAllUploadErrors));
  IVolumeDataAccessManager_.def("uploadErrorCount"            , static_cast<int32_t(IVolumeDataAccessManager::*)()>(&IVolumeDataAccessManager::UploadErrorCount), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_UploadErrorCount));
// AUTOGENERATE FAIL :   IVolumeDataAccessManager_.def("getCurrentUploadError"       , static_cast<void(IVolumeDataAccessManager::*)(const char **, int32_t *, const char **)>(&IVolumeDataAccessManager::GetCurrentUploadError), py::arg("objectId").none(false), py::arg("errorCode").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetCurrentUploadError));
// AUTOGENERATE FAIL :   IVolumeDataAccessManager_.def("getCurrentDownloadError"     , static_cast<void(IVolumeDataAccessManager::*)(int *, const char **)>(&IVolumeDataAccessManager::GetCurrentDownloadError), py::arg("code").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetCurrentDownloadError));

  // IHasVolumeDataAccess
  py::class_<IHasVolumeDataAccess, std::unique_ptr<IHasVolumeDataAccess, py::nodelete>> 
    IHasVolumeDataAccess_(m,"IHasVolumeDataAccess", OPENVDS_DOCSTRING(IHasVolumeDataAccess));

  IHasVolumeDataAccess_.def("getVolumeDataAccessManager"  , static_cast<native::IVolumeDataAccessManager *(IHasVolumeDataAccess::*)()>(&IHasVolumeDataAccess::GetVolumeDataAccessManager), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IHasVolumeDataAccess_GetVolumeDataAccessManager));
  IHasVolumeDataAccess_.def_property_readonly("volumeDataAccessManager", &IHasVolumeDataAccess::GetVolumeDataAccessManager, OPENVDS_DOCSTRING(IHasVolumeDataAccess_GetVolumeDataAccessManager));

  // VolumeDataRequest
  py::class_<VolumeDataRequest, std::shared_ptr<VolumeDataRequest>> 
    VolumeDataRequest_(m,"VolumeDataRequest", OPENVDS_DOCSTRING(VolumeDataRequest));

  VolumeDataRequest_.def(py::init<                              >(), OPENVDS_DOCSTRING(VolumeDataRequest_VolumeDataRequest));
  VolumeDataRequest_.def(py::init<native::IVolumeDataAccessManager *>(), py::arg("manager").none(false), OPENVDS_DOCSTRING(VolumeDataRequest_VolumeDataRequest_2));
  VolumeDataRequest_.def(py::init<native::IVolumeDataAccessManager *, void *, int64_t, VolumeDataChannelDescriptor::Format>(), py::arg("manager").none(false), py::arg("buffer").none(false), py::arg("bufferByteSize").none(false), py::arg("bufferDataType").none(false), OPENVDS_DOCSTRING(VolumeDataRequest_VolumeDataRequest_3));
  VolumeDataRequest_.def(py::init<native::IVolumeDataAccessManager *, int64_t, VolumeDataChannelDescriptor::Format>(), py::arg("manager").none(false), py::arg("bufferByteSize").none(false), py::arg("bufferDataType").none(false), OPENVDS_DOCSTRING(VolumeDataRequest_VolumeDataRequest_4));
  VolumeDataRequest_.def("validateRequest"             , static_cast<void(VolumeDataRequest::*)()>(&VolumeDataRequest::ValidateRequest), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_ValidateRequest));
  VolumeDataRequest_.def("requestID"                   , static_cast<int64_t(VolumeDataRequest::*)() const>(&VolumeDataRequest::RequestID), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_RequestID));
  VolumeDataRequest_.def("isCompleted"                 , static_cast<bool(VolumeDataRequest::*)()>(&VolumeDataRequest::IsCompleted), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_IsCompleted));
  VolumeDataRequest_.def_property_readonly("completed", &VolumeDataRequest::IsCompleted, OPENVDS_DOCSTRING(VolumeDataRequest_IsCompleted));
  VolumeDataRequest_.def("isCanceled"                  , static_cast<bool(VolumeDataRequest::*)()>(&VolumeDataRequest::IsCanceled), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_IsCanceled));
  VolumeDataRequest_.def_property_readonly("canceled", &VolumeDataRequest::IsCanceled, OPENVDS_DOCSTRING(VolumeDataRequest_IsCanceled));
  VolumeDataRequest_.def("waitForCompletion"           , static_cast<bool(VolumeDataRequest::*)(int)>(&VolumeDataRequest::WaitForCompletion), py::arg("millisecondsBeforeTimeout") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_WaitForCompletion));
  VolumeDataRequest_.def("cancel"                      , static_cast<void(VolumeDataRequest::*)()>(&VolumeDataRequest::Cancel), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_Cancel));
  VolumeDataRequest_.def("cancelAndWaitForCompletion"  , static_cast<void(VolumeDataRequest::*)()>(&VolumeDataRequest::CancelAndWaitForCompletion), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_CancelAndWaitForCompletion));
  VolumeDataRequest_.def("getCompletionFactor"         , static_cast<float(VolumeDataRequest::*)()>(&VolumeDataRequest::GetCompletionFactor), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_GetCompletionFactor));
  VolumeDataRequest_.def_property_readonly("completionFactor", &VolumeDataRequest::GetCompletionFactor, OPENVDS_DOCSTRING(VolumeDataRequest_GetCompletionFactor));
  VolumeDataRequest_.def("buffer"                      , static_cast<void *(VolumeDataRequest::*)() const>(&VolumeDataRequest::Buffer), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_Buffer));
  VolumeDataRequest_.def("bufferByteSize"              , static_cast<int64_t(VolumeDataRequest::*)() const>(&VolumeDataRequest::BufferByteSize), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_BufferByteSize));
  VolumeDataRequest_.def("bufferDataType"              , static_cast<VolumeDataChannelDescriptor::Format(VolumeDataRequest::*)() const>(&VolumeDataRequest::BufferDataType), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataRequest_BufferDataType));

  // VolumeDataRequest1Bit
  py::class_<VolumeDataRequest1Bit, VolumeDataRequest, std::shared_ptr<VolumeDataRequest1Bit>> 
    VolumeDataRequest1Bit_(m,"VolumeDataRequest1Bit", OPENVDS_DOCSTRING(VolumeDataRequest_t));

  // Ignored: VolumeDataRequestByte = VolumeDataRequest_t<unsigned char> already defined as VolumeDataRequest1Bit

  // VolumeDataRequestUShort
  py::class_<VolumeDataRequestUShort, VolumeDataRequest, std::shared_ptr<VolumeDataRequestUShort>> 
    VolumeDataRequestUShort_(m,"VolumeDataRequestUShort", OPENVDS_DOCSTRING(VolumeDataRequest_t));

  // VolumeDataRequestUInt
  py::class_<VolumeDataRequestUInt, VolumeDataRequest, std::shared_ptr<VolumeDataRequestUInt>> 
    VolumeDataRequestUInt_(m,"VolumeDataRequestUInt", OPENVDS_DOCSTRING(VolumeDataRequest_t));

  // VolumeDataRequestULong
  py::class_<VolumeDataRequestULong, VolumeDataRequest, std::shared_ptr<VolumeDataRequestULong>> 
    VolumeDataRequestULong_(m,"VolumeDataRequestULong", OPENVDS_DOCSTRING(VolumeDataRequest_t));

  // VolumeDataRequestFloat
  py::class_<VolumeDataRequestFloat, VolumeDataRequest, std::shared_ptr<VolumeDataRequestFloat>> 
    VolumeDataRequestFloat_(m,"VolumeDataRequestFloat", OPENVDS_DOCSTRING(VolumeDataRequest_t));

  // VolumeDataRequestDouble
  py::class_<VolumeDataRequestDouble, VolumeDataRequest, std::shared_ptr<VolumeDataRequestDouble>> 
    VolumeDataRequestDouble_(m,"VolumeDataRequestDouble", OPENVDS_DOCSTRING(VolumeDataRequest_t));

  // VolumeDataAccessManager
  py::class_<VolumeDataAccessManager> 
    VolumeDataAccessManager_(m,"VolumeDataAccessManager", OPENVDS_DOCSTRING(VolumeDataAccessManager));

  VolumeDataAccessManager_.def(py::init<                              >(), OPENVDS_DOCSTRING(VolumeDataAccessManager_VolumeDataAccessManager));
  VolumeDataAccessManager_.def(py::init<native::IVolumeDataAccessManager *>(), py::arg("manager").none(false), OPENVDS_DOCSTRING(VolumeDataAccessManager_VolumeDataAccessManager_2));
  VolumeDataAccessManager_.def(py::init<const native::VolumeDataAccessManager &>(), py::arg("rhs").none(false), OPENVDS_DOCSTRING(VolumeDataAccessManager_VolumeDataAccessManager_3));
  VolumeDataAccessManager_.def("operator_assign"             , static_cast<native::VolumeDataAccessManager &(VolumeDataAccessManager::*)(const native::VolumeDataAccessManager &)>(&VolumeDataAccessManager::operator=), py::arg("rhs").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_operator_assign));
  VolumeDataAccessManager_.def("getVolumeDataLayout"         , static_cast<const native::VolumeDataLayout *(VolumeDataAccessManager::*)()>(&VolumeDataAccessManager::GetVolumeDataLayout), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetVolumeDataLayout));
  VolumeDataAccessManager_.def_property_readonly("volumeDataLayout", &VolumeDataAccessManager::GetVolumeDataLayout, OPENVDS_DOCSTRING(VolumeDataAccessManager_GetVolumeDataLayout));
  VolumeDataAccessManager_.def("getVDSProduceStatus"         , static_cast<native::VDSProduceStatus(VolumeDataAccessManager::*)(native::DimensionsND, int, int) const>(&VolumeDataAccessManager::GetVDSProduceStatus), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetVDSProduceStatus));
  VolumeDataAccessManager_.def("createVolumeDataPageAccessor", static_cast<native::VolumeDataPageAccessor *(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, native::VolumeDataAccessManager::AccessMode, int)>(&VolumeDataAccessManager::CreateVolumeDataPageAccessor), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("accessMode").none(false), py::arg("chunkMetadataPageSize") = 1024, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeDataPageAccessor));
  VolumeDataAccessManager_.def("destroyVolumeDataPageAccessor", static_cast<void(VolumeDataAccessManager::*)(native::VolumeDataPageAccessor *)>(&VolumeDataAccessManager::DestroyVolumeDataPageAccessor), py::arg("volumeDataPageAccessor").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_DestroyVolumeDataPageAccessor));
  VolumeDataAccessManager_.def("createVolumeData2DInterpolatingAccessorR64", static_cast<native::VolumeData2DInterpolatingAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DInterpolatingAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DInterpolatingAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData2DInterpolatingAccessorR64", static_cast<native::VolumeData2DInterpolatingAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DInterpolatingAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DInterpolatingAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData2DInterpolatingAccessorR32", static_cast<native::VolumeData2DInterpolatingAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DInterpolatingAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DInterpolatingAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData2DInterpolatingAccessorR32", static_cast<native::VolumeData2DInterpolatingAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DInterpolatingAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DInterpolatingAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessor1Bit", static_cast<native::VolumeData2DReadAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessor1Bit));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessor1Bit", static_cast<native::VolumeData2DReadAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessor1Bit_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU8", static_cast<native::VolumeData2DReadAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU8));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU8", static_cast<native::VolumeData2DReadAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU8_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU16", static_cast<native::VolumeData2DReadAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU16));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU16", static_cast<native::VolumeData2DReadAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU16_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU32", static_cast<native::VolumeData2DReadAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU32));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU32", static_cast<native::VolumeData2DReadAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU32_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU64", static_cast<native::VolumeData2DReadAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU64));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorU64", static_cast<native::VolumeData2DReadAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorU64_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorR32", static_cast<native::VolumeData2DReadAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorR32", static_cast<native::VolumeData2DReadAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorR64", static_cast<native::VolumeData2DReadAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData2DReadAccessorR64", static_cast<native::VolumeData2DReadAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessor1Bit", static_cast<native::VolumeData2DReadWriteAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessor1Bit));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessor1Bit", static_cast<native::VolumeData2DReadWriteAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessor1Bit_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU8", static_cast<native::VolumeData2DReadWriteAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU8));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU8", static_cast<native::VolumeData2DReadWriteAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU8_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU16", static_cast<native::VolumeData2DReadWriteAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU16));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU16", static_cast<native::VolumeData2DReadWriteAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU16_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU32", static_cast<native::VolumeData2DReadWriteAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU32));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU32", static_cast<native::VolumeData2DReadWriteAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU32_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU64", static_cast<native::VolumeData2DReadWriteAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU64));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorU64", static_cast<native::VolumeData2DReadWriteAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorU64_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorR32", static_cast<native::VolumeData2DReadWriteAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorR32", static_cast<native::VolumeData2DReadWriteAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorR64", static_cast<native::VolumeData2DReadWriteAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData2DReadWriteAccessorR64", static_cast<native::VolumeData2DReadWriteAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData2DReadWriteAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData2DReadWriteAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData3DInterpolatingAccessorR64", static_cast<native::VolumeData3DInterpolatingAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DInterpolatingAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DInterpolatingAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData3DInterpolatingAccessorR64", static_cast<native::VolumeData3DInterpolatingAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DInterpolatingAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DInterpolatingAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData3DInterpolatingAccessorR32", static_cast<native::VolumeData3DInterpolatingAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DInterpolatingAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DInterpolatingAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData3DInterpolatingAccessorR32", static_cast<native::VolumeData3DInterpolatingAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DInterpolatingAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DInterpolatingAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessor1Bit", static_cast<native::VolumeData3DReadAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessor1Bit));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessor1Bit", static_cast<native::VolumeData3DReadAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessor1Bit_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU8", static_cast<native::VolumeData3DReadAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU8));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU8", static_cast<native::VolumeData3DReadAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU8_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU16", static_cast<native::VolumeData3DReadAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU16));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU16", static_cast<native::VolumeData3DReadAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU16_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU32", static_cast<native::VolumeData3DReadAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU32));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU32", static_cast<native::VolumeData3DReadAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU32_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU64", static_cast<native::VolumeData3DReadAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU64));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorU64", static_cast<native::VolumeData3DReadAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorU64_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorR32", static_cast<native::VolumeData3DReadAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorR32", static_cast<native::VolumeData3DReadAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorR64", static_cast<native::VolumeData3DReadAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData3DReadAccessorR64", static_cast<native::VolumeData3DReadAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessor1Bit", static_cast<native::VolumeData3DReadWriteAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessor1Bit));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessor1Bit", static_cast<native::VolumeData3DReadWriteAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessor1Bit_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU8", static_cast<native::VolumeData3DReadWriteAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU8));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU8", static_cast<native::VolumeData3DReadWriteAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU8_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU16", static_cast<native::VolumeData3DReadWriteAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU16));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU16", static_cast<native::VolumeData3DReadWriteAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU16_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU32", static_cast<native::VolumeData3DReadWriteAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU32));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU32", static_cast<native::VolumeData3DReadWriteAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU32_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU64", static_cast<native::VolumeData3DReadWriteAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU64));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorU64", static_cast<native::VolumeData3DReadWriteAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorU64_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorR32", static_cast<native::VolumeData3DReadWriteAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorR32", static_cast<native::VolumeData3DReadWriteAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorR64", static_cast<native::VolumeData3DReadWriteAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData3DReadWriteAccessorR64", static_cast<native::VolumeData3DReadWriteAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData3DReadWriteAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData3DReadWriteAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData4DInterpolatingAccessorR64", static_cast<native::VolumeData4DInterpolatingAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DInterpolatingAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DInterpolatingAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData4DInterpolatingAccessorR64", static_cast<native::VolumeData4DInterpolatingAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DInterpolatingAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DInterpolatingAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData4DInterpolatingAccessorR32", static_cast<native::VolumeData4DInterpolatingAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DInterpolatingAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DInterpolatingAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData4DInterpolatingAccessorR32", static_cast<native::VolumeData4DInterpolatingAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, native::InterpolationMethod, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DInterpolatingAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DInterpolatingAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessor1Bit", static_cast<native::VolumeData4DReadAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessor1Bit));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessor1Bit", static_cast<native::VolumeData4DReadAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessor1Bit_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU8", static_cast<native::VolumeData4DReadAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU8));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU8", static_cast<native::VolumeData4DReadAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU8_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU16", static_cast<native::VolumeData4DReadAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU16));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU16", static_cast<native::VolumeData4DReadAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU16_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU32", static_cast<native::VolumeData4DReadAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU32));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU32", static_cast<native::VolumeData4DReadAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU32_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU64", static_cast<native::VolumeData4DReadAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU64));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorU64", static_cast<native::VolumeData4DReadAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorU64_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorR32", static_cast<native::VolumeData4DReadAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorR32", static_cast<native::VolumeData4DReadAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorR64", static_cast<native::VolumeData4DReadAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData4DReadAccessorR64", static_cast<native::VolumeData4DReadAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadAccessorR64_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessor1Bit", static_cast<native::VolumeData4DReadWriteAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessor1Bit));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessor1Bit", static_cast<native::VolumeData4DReadWriteAccessor1Bit(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessor1Bit), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessor1Bit_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU8", static_cast<native::VolumeData4DReadWriteAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU8));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU8", static_cast<native::VolumeData4DReadWriteAccessorU8(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU8), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU8_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU16", static_cast<native::VolumeData4DReadWriteAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU16));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU16", static_cast<native::VolumeData4DReadWriteAccessorU16(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU16), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU16_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU32", static_cast<native::VolumeData4DReadWriteAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU32));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU32", static_cast<native::VolumeData4DReadWriteAccessorU32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU32_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU64", static_cast<native::VolumeData4DReadWriteAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU64));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorU64", static_cast<native::VolumeData4DReadWriteAccessorU64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorU64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorU64_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorR32", static_cast<native::VolumeData4DReadWriteAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorR32));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorR32", static_cast<native::VolumeData4DReadWriteAccessorR32(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorR32), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorR32_2));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorR64", static_cast<native::VolumeData4DReadWriteAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("maxPages").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorR64));
  VolumeDataAccessManager_.def("createVolumeData4DReadWriteAccessorR64", static_cast<native::VolumeData4DReadWriteAccessorR64(VolumeDataAccessManager::*)(native::DimensionsND, int, int, optional<float>)>(&VolumeDataAccessManager::CreateVolumeData4DReadWriteAccessorR64), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_CreateVolumeData4DReadWriteAccessorR64_2));
  VolumeDataAccessManager_.def("getVolumeSubsetBufferSize"   , [](VolumeDataAccessManager* self, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, VolumeDataChannelDescriptor::Format format, int LOD, int channel) { return self->GetVolumeSubsetBufferSize(PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), format, LOD, channel); }, py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("format").none(false), py::arg("LOD") = 0, py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetVolumeSubsetBufferSize));
  VolumeDataAccessManager_.def("requestVolumeSubset"         , [](VolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, VolumeDataChannelDescriptor::Format format, optional<float> replacementNoValue) { return self->RequestVolumeSubset(PyGetBufferPtr<void, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), format, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("format").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeSubset));
  VolumeDataAccessManager_.def("requestVolumeSubset1Bit"     , [](VolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates) { return self->RequestVolumeSubset1Bit(PyGetBufferPtr<uint8_t, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates)); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeSubset1Bit));
  VolumeDataAccessManager_.def("requestVolumeSubset"         , [](VolumeDataAccessManager* self, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, VolumeDataChannelDescriptor::Format format, optional<float> replacementNoValue) { return self->RequestVolumeSubset(dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), format, replacementNoValue); }, py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("format").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeSubset_2));
  VolumeDataAccessManager_.def("requestVolumeSubset1Bit"     , [](VolumeDataAccessManager* self, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates) { return self->RequestVolumeSubset1Bit(dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates)); }, py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeSubset1Bit_2));
  VolumeDataAccessManager_.def("getProjectedVolumeSubsetBufferSize", [](VolumeDataAccessManager* self, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, OpenVDS::DimensionsND projectedDimensions, VolumeDataChannelDescriptor::Format format, int LOD, int channel) { return self->GetProjectedVolumeSubsetBufferSize(PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), projectedDimensions, format, LOD, channel); }, py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("projectedDimensions").none(false), py::arg("format").none(false), py::arg("LOD") = 0, py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetProjectedVolumeSubsetBufferSize));
  VolumeDataAccessManager_.def("requestProjectedVolumeSubset", [](VolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, FloatVector4Adapter::AdaptedType voxelPlane, OpenVDS::DimensionsND projectedDimensions, VolumeDataChannelDescriptor::Format format, OpenVDS::InterpolationMethod interpolationMethod, optional<float> replacementNoValue) { return self->RequestProjectedVolumeSubset(PyGetBufferPtr<void, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), voxelPlane, projectedDimensions, format, interpolationMethod, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("voxelPlane").none(false), py::arg("projectedDimensions").none(false), py::arg("format").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestProjectedVolumeSubset));
  VolumeDataAccessManager_.def("requestProjectedVolumeSubset", [](VolumeDataAccessManager* self, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<int,py::array::forcecast>& minVoxelCoordinates, const py::array_t<int,py::array::forcecast>& maxVoxelCoordinates, FloatVector4Adapter::AdaptedType voxelPlane, OpenVDS::DimensionsND projectedDimensions, VolumeDataChannelDescriptor::Format format, OpenVDS::InterpolationMethod interpolationMethod, optional<float> replacementNoValue) { return self->RequestProjectedVolumeSubset(dimensionsND, LOD, channel, PyArrayAdapter<int, 6, false>::getArrayChecked(minVoxelCoordinates), PyArrayAdapter<int, 6, false>::getArrayChecked(maxVoxelCoordinates), voxelPlane, projectedDimensions, format, interpolationMethod, replacementNoValue); }, py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("minVoxelCoordinates").none(false), py::arg("maxVoxelCoordinates").none(false), py::arg("voxelPlane").none(false), py::arg("projectedDimensions").none(false), py::arg("format").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestProjectedVolumeSubset_2));
  VolumeDataAccessManager_.def("getVolumeSamplesBufferSize"  , static_cast<int64_t(VolumeDataAccessManager::*)(int, int)>(&VolumeDataAccessManager::GetVolumeSamplesBufferSize), py::arg("sampleCount").none(false), py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetVolumeSamplesBufferSize));
  VolumeDataAccessManager_.def("requestVolumeSamples"        , [](VolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<float,py::array::forcecast>& samplePositions, int sampleCount, OpenVDS::InterpolationMethod interpolationMethod, optional<float> replacementNoValue) { return self->RequestVolumeSamples(PyGetBufferPtr<float, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<float, 6, false>::getArrayPtrChecked(samplePositions), sampleCount, interpolationMethod, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("samplePositions").none(false), py::arg("sampleCount").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeSamples));
  VolumeDataAccessManager_.def("requestVolumeSamples"        , [](VolumeDataAccessManager* self, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<float,py::array::forcecast>& samplePositions, int sampleCount, OpenVDS::InterpolationMethod interpolationMethod, optional<float> replacementNoValue) { return self->RequestVolumeSamples(dimensionsND, LOD, channel, PyArrayAdapter<float, 6, false>::getArrayPtrChecked(samplePositions), sampleCount, interpolationMethod, replacementNoValue); }, py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("samplePositions").none(false), py::arg("sampleCount").none(false), py::arg("interpolationMethod").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeSamples_2));
  VolumeDataAccessManager_.def("getVolumeTracesBufferSize"   , static_cast<int64_t(VolumeDataAccessManager::*)(int, int, int, int)>(&VolumeDataAccessManager::GetVolumeTracesBufferSize), py::arg("traceCount").none(false), py::arg("traceDimension").none(false), py::arg("LOD") = 0, py::arg("channel") = 0, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetVolumeTracesBufferSize));
  VolumeDataAccessManager_.def("requestVolumeTraces"         , [](VolumeDataAccessManager* self, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<float,py::array::forcecast>& tracePositions, int traceCount, OpenVDS::InterpolationMethod interpolationMethod, int traceDimension, optional<float> replacementNoValue) { return self->RequestVolumeTraces(dimensionsND, LOD, channel, PyArrayAdapter<float, 6, false>::getArrayPtrChecked(tracePositions), traceCount, interpolationMethod, traceDimension, replacementNoValue); }, py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("tracePositions").none(false), py::arg("traceCount").none(false), py::arg("interpolationMethod").none(false), py::arg("traceDimension").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeTraces));
  VolumeDataAccessManager_.def("requestVolumeTraces"         , [](VolumeDataAccessManager* self, py::buffer buffer, OpenVDS::DimensionsND dimensionsND, int LOD, int channel, const py::array_t<float,py::array::forcecast>& tracePositions, int traceCount, OpenVDS::InterpolationMethod interpolationMethod, int traceDimension, optional<float> replacementNoValue) { return self->RequestVolumeTraces(PyGetBufferPtr<float, true>(buffer), PyGetBufferSize<int64_t, true>(buffer), dimensionsND, LOD, channel, PyArrayAdapter<float, 6, false>::getArrayPtrChecked(tracePositions), traceCount, interpolationMethod, traceDimension, replacementNoValue); }, py::arg("buffer").none(false), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("tracePositions").none(false), py::arg("traceCount").none(false), py::arg("interpolationMethod").none(false), py::arg("traceDimension").none(false), py::arg("replacementNoValue") = nullptr, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_RequestVolumeTraces_2));
  VolumeDataAccessManager_.def("prefetchVolumeChunk"         , static_cast<std::shared_ptr<VolumeDataRequest>(VolumeDataAccessManager::*)(native::DimensionsND, int, int, int64_t)>(&VolumeDataAccessManager::PrefetchVolumeChunk), py::arg("dimensionsND").none(false), py::arg("LOD").none(false), py::arg("channel").none(false), py::arg("chunkIndex").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_PrefetchVolumeChunk));
  VolumeDataAccessManager_.def("flushUploadQueue"            , static_cast<void(VolumeDataAccessManager::*)(bool)>(&VolumeDataAccessManager::FlushUploadQueue), py::arg("writeUpdatedLayerStatus") = true, py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_FlushUploadQueue));
  VolumeDataAccessManager_.def("clearUploadErrors"           , static_cast<void(VolumeDataAccessManager::*)()>(&VolumeDataAccessManager::ClearUploadErrors), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_ClearUploadErrors));
  VolumeDataAccessManager_.def("forceClearAllUploadErrors"   , static_cast<void(VolumeDataAccessManager::*)()>(&VolumeDataAccessManager::ForceClearAllUploadErrors), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_ForceClearAllUploadErrors));
  VolumeDataAccessManager_.def("uploadErrorCount"            , static_cast<int32_t(VolumeDataAccessManager::*)()>(&VolumeDataAccessManager::UploadErrorCount), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_UploadErrorCount));
// AUTOGENERATE FAIL :   VolumeDataAccessManager_.def("getCurrentUploadError"       , static_cast<void(VolumeDataAccessManager::*)(const char **, int32_t *, const char **)>(&VolumeDataAccessManager::GetCurrentUploadError), py::arg("objectId").none(false), py::arg("errorCode").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetCurrentUploadError));
// AUTOGENERATE FAIL :   VolumeDataAccessManager_.def("getCurrentDownloadError"     , static_cast<void(VolumeDataAccessManager::*)(int *, const char **)>(&VolumeDataAccessManager::GetCurrentDownloadError), py::arg("code").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetCurrentDownloadError));

//AUTOGEN-END

// IMPLEMENTED :   IVolumeDataAccessManager_.def("getCurrentUploadError"       , static_cast<void(IVolumeDataAccessManager::*)(const char **, int32_t *, const char **)>(&IVolumeDataAccessManager::GetCurrentUploadError), py::arg("objectId").none(false), py::arg("errorCode").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetCurrentUploadError));
  IVolumeDataAccessManager_.def("getCurrentUploadError"       , [](IVolumeDataAccessManager* self)
    {
      const char
        *pObjectID = nullptr,
        *pErrorString = nullptr;

      int32_t
        errorCode = 0;

      self->GetCurrentUploadError(&pObjectID, &errorCode, &pErrorString);
      if(errorCode != 0)
      {
        return py::cast(std::make_tuple(std::string(pObjectID ? pObjectID : ""), errorCode, std::string(pErrorString ? pErrorString : "")));
      }
      else
      {
        return py::cast(Py_None);
      }
    }, OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetCurrentUploadError));

// IMPLEMENTED :   IVolumeDataAccessManager_.def("getCurrentDownloadError"     , static_cast<void(IVolumeDataAccessManager::*)(int *, const char **)>(&IVolumeDataAccessManager::GetCurrentDownloadError), py::arg("code").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetCurrentDownloadError));
  IVolumeDataAccessManager_.def("getCurrentDownloadError"       , [](IVolumeDataAccessManager* self)
    {
      const char
        *pErrorString = nullptr;

      int32_t
        errorCode = 0;

      self->GetCurrentDownloadError(&errorCode, &pErrorString);
      if(errorCode != 0)
      {
        return py::cast(std::make_tuple(errorCode, std::string(pErrorString ? pErrorString : "")));
      }
      else
      {
        return py::cast(Py_None);
      }
    }, OPENVDS_DOCSTRING(IVolumeDataAccessManager_GetCurrentDownloadError));

// IMPLEMENTED :   VolumeDataAccessManager_.def("getCurrentUploadError"       , static_cast<void(VolumeDataAccessManager::*)(const char **, int32_t *, const char **)>(&VolumeDataAccessManager::GetCurrentUploadError), py::arg("objectId").none(false), py::arg("errorCode").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetCurrentUploadError));
  VolumeDataAccessManager_.def("getCurrentUploadError"       , [](VolumeDataAccessManager* self)
    {
      const char
        *pObjectID = nullptr,
        *pErrorString = nullptr;

      int32_t
        errorCode = 0;

      self->GetCurrentUploadError(&pObjectID, &errorCode, &pErrorString);
      if(errorCode != 0)
      {
        return py::cast(std::make_tuple(std::string(pObjectID ? pObjectID : ""), errorCode, std::string(pErrorString ? pErrorString : "")));
      }
      else
      {
        return py::cast(Py_None);
      }
    }, OPENVDS_DOCSTRING(VolumeDataAccessManager_GetCurrentUploadError));

// IMPLEMENTED :   VolumeDataAccessManager_.def("getCurrentDownloadError"     , static_cast<void(VolumeDataAccessManager::*)(int *, const char **)>(&VolumeDataAccessManager::GetCurrentDownloadError), py::arg("code").none(false), py::arg("errorString").none(false), py::call_guard<py::gil_scoped_release>(), OPENVDS_DOCSTRING(VolumeDataAccessManager_GetCurrentDownloadError));
  VolumeDataAccessManager_.def("getCurrentDownloadError"       , [](VolumeDataAccessManager* self)
    {
      const char
        *pErrorString = nullptr;

      int32_t
        errorCode = 0;

      self->GetCurrentDownloadError(&errorCode, &pErrorString);
      if(errorCode != 0)
      {
        return py::cast(std::make_tuple(errorCode, std::string(pErrorString ? pErrorString : "")));
      }
      else
      {
        return py::cast(Py_None);
      }
    }, OPENVDS_DOCSTRING(VolumeDataAccessManager_GetCurrentDownloadError));

  IVolumeDataAccessManager_.attr("Dimensionality_Max") = py::int_(VolumeDataAccessManager::Dimensionality_Max);
  VolumeDataAccessManager_.attr("Dimensionality_Max") = py::int_(VolumeDataAccessManager::Dimensionality_Max);
  VolumeDataAccessManager_.attr("maxPagesDefault") = py::int_(VolumeDataAccessManager::maxPagesDefault);
}

